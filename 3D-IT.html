<!DOCTYPE html>
<html>
<head>
    <title>3D IT 框架</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <script src="build/three.js"></script>
        <script src="js/controls/OrbitControls.js"></script>
        <script src="js/loaders/OBJLoader.js"></script>

        <script src="js/Detector.js"></script>

        <script src="js/shaders/CopyShader.js"></script>
        <script src="js/shaders/FXAAShader.js"></script>
        <script src="js/postprocessing/EffectComposer.js"></script>
        <script src="js/postprocessing/RenderPass.js"></script>
        <script src="js/postprocessing/ShaderPass.js"></script>
        <script src="js/postprocessing/OutlinePass.js"></script>
        <script src="js/libs/stats.min.js"></script>
        <script src='js/libs/dat.gui.min.js'></script>

    <script src='js/libs/dat.gui.min.js'></script>
    
    <style type="text/css">
        body {
                background-color: #000000;
                margin: 0px;
                overflow: hidden;
                font-family:Monospace;
                font-size:13px;
                text-align:center;
                font-weight: bold;
            }
    </style>
</head>
<body>
<div id="container"></div>

<script>
    var scene, camera, controls,raycaster;
    var renderer,composer,outlinePass,effectFXAA;

    var mouse = new THREE.Vector2();
    var selectedObjects = [];

    var SCREEN_WIDTH = window.innerWidth;
    var SCREEN_HEIGHT = window.innerHeight;
    var devicePixelRatio = window.devicePixelRatio || 1;

    var container = document.getElementById( 'container' );

    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.shadowMap.enabled = true;
    renderer.setClearColor( 0xffffff );
    renderer.setPixelRatio( devicePixelRatio );
    renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
    container.appendChild( renderer.domElement );

    var url = 'scene.json';

    var lineMaterial = new THREE.LineBasicMaterial({
            color: 0x0000ff,
            linewidth :10,
            opacity:1
        });

    var geometry = new THREE.Geometry();//存放线条的vertices
    var boxGroup = new Array();
    var lineGroup = new THREE.Group();
    lineGroup.name='lineGroup';

    raycaster = new THREE.Raycaster();
    raycaster.linePrecision = 3;
    // Load a scene with objects, lights and camera from a JSON file

    new THREE.ObjectLoader().load( url, function ( loadedScene ) {

        scene = loadedScene;

        scene.traverse( function ( sceneChild ) {

            if ( sceneChild.type === 'PerspectiveCamera' ) {

                camera = sceneChild;
                camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
                camera.updateProjectionMatrix();

            }

            if(sceneChild.type == 'Mesh'){

                if(sceneChild.geometry.type == 'BoxBufferGeometry' || sceneChild.geometry.type == 'SphereBufferGeometry'){
                    boxGroup.push(sceneChild);
                    geometry.vertices.push(sceneChild.position);
                }
            }

        } );
        //geometry.vertices.push(geometry.vertices[0]);
    
        var line = new THREE.Line( geometry, lineMaterial );
        line.position.y -= 1;
        scene.add( line );


        // ... else create a new camera and use it in the loaded scene

        if ( camera === undefined ) {

            camera = new THREE.PerspectiveCamera( 30, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 10000 );
            camera.position.set( 10, 30, 20 );

        }

        controls = new THREE.OrbitControls( camera );
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;

        scene.background = new THREE.Color(0x111111);
        postProcessing();//函数调用位置，解决了overriddenmaterial的问题
        document.addEventListener( 'mousedown', onDocumentMouseDown, false );
        document.addEventListener( 'mousemove', onTouchMove );
        document.addEventListener( 'touchmove', onTouchMove );

        animate();

            } );
    function hexToRgb( hex ) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[ 1 ], 16),
            g: parseInt(result[ 2 ], 16),
            b: parseInt(result[ 3 ], 16)
        } : null;
    }

    function postProcessing(){

        composer = new THREE.EffectComposer( renderer );

        var renderPass = new THREE.RenderPass( scene, camera );
        composer.addPass( renderPass );

        outlinePass = new THREE.OutlinePass( new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
        outlinePass.edgeStrength = 3.5;
        outlinePass.edgeGlow = 1;
        outlinePass.edgeThickness = 2.2;
        outlinePass.pulsePeriod = 3;

        outlinePass.visibleEdgeColor = '#ffffff';
        var colorValue = outlinePass.visibleEdgeColor.replace('#', '');
        var rgba  = hexToRgb(colorValue);
        var color = new THREE.Color() ;
        color.r   = rgba.r / 255;
        color.g   = rgba.g / 255;
        color.b   = rgba.b / 255;
        outlinePass.visibleEdgeColor = color;

        outlinePass.hiddenEdgeColor = '#190a05';
        var colorValue = outlinePass.hiddenEdgeColor.replace('#', '');
        var rgba  = hexToRgb(colorValue);
        var color = new THREE.Color();
        color.r   = rgba.r / 255;
        color.g   = rgba.g / 255;
        color.b   = rgba.b / 255;
        outlinePass.hiddenEdgeColor = color;

        composer.addPass( outlinePass );

        var onLoad = function ( texture ) {
            outlinePass.patternTexture = texture;
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
        };

        var loader = new THREE.TextureLoader();

        loader.load(

            'tri_pattern.jpg',
            onLoad
        );

        effectFXAA = new THREE.ShaderPass(THREE.FXAAShader);
        effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight );
        effectFXAA.renderToScreen = true;
        composer.addPass( effectFXAA );
    }
    

    window.onresize = function () {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        composer.setSize( window.innerWidth, window.innerHeight );
        effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight );
        renderer.setSize( window.innerWidth, window.innerHeight );

            };

    function onDocumentMouseDown( event ) {

        event.preventDefault();

        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

        raycaster.setFromCamera( mouse, camera );

        var intersects = raycaster.intersectObjects( boxGroup );

        var lineChange = new THREE.Line( geometryChange, lineChangeMaterial );
        var geometryChange = new THREE.Geometry();
        var lineChangeMaterial = new THREE.LineBasicMaterial({
                color: 0xC02121,
                linewidth :30,
                opacity:1
            });
        
        if ( intersects.length > 0 ) {

            geometryChange = new THREE.Geometry();

            var object = intersects[0].object;
            var position = intersects[0].object.position;

            //搜索 geometry.vertices 中的 position 重新绘制选中物体相关linet
            var p = geometry.vertices.length;
            for(i=0;i<p;i++){
                if(geometry.vertices[i] == position){

                    if (i == p - 1){
                        geometryChange.vertices.push(geometry.vertices[p - 2]);
                        geometryChange.vertices.push(position);
                    }
                    else if(i == 0){
                        geometryChange.vertices.push(position);
                        geometryChange.vertices.push(geometry.vertices[i+1]);
                    }

                    else{
                        geometryChange.vertices.push(geometry.vertices[i-1]);
                        geometryChange.vertices.push(position);
                        geometryChange.vertices.push(geometry.vertices[i+1]);
                        
                    }
                }
            }
            lineChange = new THREE.Line( geometryChange, lineChangeMaterial );
            lineChange.position.y -= 1;
            lineGroup.add(lineChange)
            scene.add( lineGroup );

        }

     }

    function onTouchMove( event ) {

        var x, y;

        if ( event.changedTouches ) {

            x = event.changedTouches[ 0 ].pageX;
            y = event.changedTouches[ 0 ].pageY;

        } else {

            x = event.clientX;
            y = event.clientY;

        }

        mouse.x = ( x / window.innerWidth ) * 2 - 1;
        mouse.y = - ( y / window.innerHeight ) * 2 + 1;

        checkIntersection();

        }

    function addSelectedObject(object) {
        selectedObjects = [];
        selectedObjects.push(object);
    }

    function checkIntersection() {

        raycaster.setFromCamera( mouse, camera );

        var intersects = raycaster.intersectObjects( boxGroup );

        if ( intersects.length > 0 ) {
            var selectedObject = intersects[ 0 ].object;
            addSelectedObject(selectedObject);
            outlinePass.selectedObjects = selectedObjects;
        }
    }

    function animate() {

        requestAnimationFrame( animate );
        renderer.autoClear = true;
        renderer.setClearColor( 0xfff0f0 );
        renderer.setClearAlpha( 0.0 );
        //renderer.render( scene, camera );
        composer.render();

            }
</script>
</body>
</html>