<!DOCTYPE html>
<html>
<head>
    <title>3D IT 框架</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <script src="js/libs/jquery-3.2.1.js"></script>
    <script type="text/javascript" src="build/three.js"></script>
    <script src="js/controls/OrbitControls.js"></script>
    <script src="js/Detector.js"></script>

    <script src="js/shaders/SSAOShader.js"></script>
    <script src="js/shaders/CopyShader.js"></script>
    <script src="js/shaders/FXAAShader.js"></script>
    <script src="js/shaders/ConvolutionShader.js"></script>
    <script src="js/shaders/LuminosityHighPassShader.js"></script>
    <script src="js/shaders/DepthLimitedBlurShader.js"></script>
    <script src="js/shaders/UnpackDepthRGBAShader.js"></script>

    <script src="js/postprocessing/EffectComposer.js"></script>
    <script src="js/postprocessing/RenderPass.js"></script>
    <script src="js/postprocessing/ShaderPass.js"></script>
    <script src="js/postprocessing/MaskPass.js"></script>
    <script src="js/postprocessing/OutlinePass.js"></script>
    
    <style type="text/css">
        html {

        height: 100%;

        margin:0;

    }

    body {

        height: 100%;

        margin: 0;

        color: #938E8E;

        /*background-color: #111;*/

        background-image: url('image/3.jpg');

        background-size:100% 100%;

        overflow-x:hidden;

        overflow-y:hidden;

    }
    </style>
</head>
<body>
<div id="container"></div>

<script>
    var scene, camera, controls,raycaster;
    var renderer,effectComposer,depthRenderTarget;
    var mouse = new THREE.Vector2();

    var SCREEN_WIDTH = window.innerWidth;
    var SCREEN_HEIGHT = window.innerHeight;

    var container = document.getElementById( 'container' );
    renderer = new THREE.WebGLRenderer( { antialias: true,alpha:true } );
    renderer.setClearColor( 0xffffff );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
    container.appendChild( renderer.domElement );

    var url = 'scene.json';

    var lineMaterial = new THREE.LineBasicMaterial({
            color: 0x0000ff,
            linewidth :1,
            opacity:0.9
        });

    var geometry = new THREE.Geometry();//存放线条的vertices
    var boxGroup = new Array();
    var lineGroup = new THREE.Group();
    lineGroup.name='lineGroup';

    raycaster = new THREE.Raycaster();
    raycaster.linePrecision = 3;
    // Load a scene with objects, lights and camera from a JSON file

    function initSSAOPostprocessing() {

        var ssaoPass;

        // Setup render pass
        var renderPass = new THREE.RenderPass( scene, camera );

        // Setup depth pass
        depthMaterial = new THREE.MeshDepthMaterial();
        depthMaterial.depthPacking = THREE.RGBADepthPacking;
        depthMaterial.blending = THREE.NoBlending;

        var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter };
        depthRenderTarget = new THREE.WebGLRenderTarget( SCREEN_WIDTH, SCREEN_HEIGHT, pars );
        depthRenderTarget.texture.name = "SSAOShader.rt";

        // Setup SSAO pass
        ssaoPass = new THREE.ShaderPass( THREE.SSAOShader );
        ssaoPass.renderToScreen = true;
        //ssaoPass.uniforms[ "tDiffuse" ].value will be set by ShaderPass
        ssaoPass.uniforms[ "tDepth" ].value = depthRenderTarget.texture;
        ssaoPass.uniforms[ 'size' ].value.set( SCREEN_WIDTH, SCREEN_HEIGHT );
        ssaoPass.uniforms[ 'cameraNear' ].value = camera.near;
        ssaoPass.uniforms[ 'cameraFar' ].value = camera.far;
        ssaoPass.uniforms[ 'onlyAO' ].value = false;
        ssaoPass.uniforms[ 'aoClamp' ].value = 0.3;
        ssaoPass.uniforms[ 'lumInfluence' ].value = 0.5;

        // Add pass to effect composer
        
        effectComposer = new THREE.EffectComposer( renderer );
        effectComposer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
        effectComposer.addPass( renderPass );
        effectComposer.addPass( ssaoPass );

        }

    new THREE.ObjectLoader().load( url, function ( loadedScene ) {

        scene = loadedScene;

        // If the loaded file contains a perspective camera, use it with adjusted aspect ratio...

        scene.traverse( function ( sceneChild ) {

            if ( sceneChild.type === 'PerspectiveCamera' ) {

                camera = sceneChild;
                camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
                camera.updateProjectionMatrix();

            }

            if(sceneChild.type == 'Mesh'){

                if(sceneChild.geometry.type == 'BoxBufferGeometry' || sceneChild.geometry.type == 'SphereBufferGeometry'){
                    boxGroup.push(sceneChild);
                    geometry.vertices.push(sceneChild.position);
                }
            }

        } );
        //geometry.vertices.push(geometry.vertices[0]);
    
        var line = new THREE.Line( geometry, lineMaterial );
        line.position.y -= 1;
        scene.add( line );


        // ... else create a new camera and use it in the loaded scene

        if ( camera === undefined ) {

            camera = new THREE.PerspectiveCamera( 30, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 10000 );
            camera.position.set( 10, 30, 20 );

        }

        controls = new THREE.OrbitControls( camera );
        scene.background = new THREE.Color(0x111111);

        document.addEventListener( 'mousedown', onDocumentMouseDown, false );

        animate();

            } );

    window.onresize = function () {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

            };

    function onDocumentMouseDown( event ) {

        event.preventDefault();

        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

            }

    function animate() {

        requestAnimationFrame( animate );
        render();

            }

    function render() {
        
        raycaster.setFromCamera( mouse, camera );

        var intersects = raycaster.intersectObjects( boxGroup );

        var lineChange = new THREE.Line( geometryChange, lineChangeMaterial );
        var geometryChange = new THREE.Geometry();
        var lineChangeMaterial = new THREE.LineBasicMaterial({
                color: 0xC02121,
                linewidth :3,
                opacity:0.5
            });
        
        if ( intersects.length > 0 ) {
            scene.remove( lineGroup );
            geometryChange = new THREE.Geometry();

            var object = intersects[0].object;
            var position = intersects[0].object.position;

            //搜索 geometry.vertices 中的 position 重新绘制选中物体相关linet
            var p = geometry.vertices.length;
            for(i=0;i<p;i++){
                if(geometry.vertices[i] == position){

                    if (i == p - 1){
                        geometryChange.vertices.push(geometry.vertices[p - 2]);
                        geometryChange.vertices.push(position);
                    }
                    else if(i == 0){
                        geometryChange.vertices.push(position);
                        geometryChange.vertices.push(geometry.vertices[i+1]);
                    }

                    else{
                        geometryChange.vertices.push(geometry.vertices[i-1]);
                        geometryChange.vertices.push(position);
                        geometryChange.vertices.push(geometry.vertices[i+1]);
                        
                    }
                }
            }
            lineChange = new THREE.Line( geometryChange, lineChangeMaterial );
            lineChange.position.y -= 1;
            lineGroup.add(lineChange)
            scene.add( lineGroup );

        }
        renderer.render( scene, camera );
        //initSSAOPostprocessing();
        // Render depth into depthRenderTarget
       
        //renderer.render( scene, camera, depthRenderTarget, true );

        // Render renderPass and SSAO shaderPass
        // scene.overrideMaterial = null;
        // effectComposer.render();
        // effectComposer.render( scene, camera );

            }
</script>
</body>
</html>