<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - post processing - Outline Pass</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                background-color: #000000;
                margin: 0px;
                overflow: hidden;
                font-family:Monospace;
                font-size:13px;
                text-align:center;
                font-weight: bold;
            }

            a {
                color:#00ff78;
            }

            #info {
                color: #fff;
                position: absolute;
                top: 10px;
                width: 100%;
                text-align: center;
                display:block;
            }
            .dg.ac {
                z-index: 1 !important; /* FIX DAT.GUI */
            }
        </style>
    </head>
    <body>
        <script src="build/three.js"></script>
        <script src="js/controls/OrbitControls.js"></script>
        <script src="js/loaders/OBJLoader.js"></script>

        <script src="js/Detector.js"></script>

        <script src="js/shaders/CopyShader.js"></script>
        <script src="js/shaders/FXAAShader.js"></script>
        <script src="js/postprocessing/EffectComposer.js"></script>
        <script src="js/postprocessing/RenderPass.js"></script>
        <script src="js/postprocessing/ShaderPass.js"></script>
        <script src="js/postprocessing/OutlinePass.js"></script>
        <script src="js/libs/stats.min.js"></script>
        <script src='js/libs/dat.gui.min.js'></script>

        <div id="info">
            <a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - Outline Pass by <a href="http://eduperiment.com" target="_blank" rel="noopener">Prashant Sharma</a> and <a href="https://clara.io" target="_blank" rel="noopener">Ben Houston</a><br/><br/>
        </div>

        <script>

            if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

            var container, stats;
            var camera, scene, renderer, controls;
            var mesh, decal;
            var raycaster = new THREE.Raycaster();

            var mouse = new THREE.Vector2();
            var selectedObjects = [];

            var composer, effectFXAA, outlinePass;
            var obj3d = new THREE.Object3D();

var geometry = new THREE.Geometry();//存放线条的vertices
    var boxGroup = new Array();
    var lineGroup = new THREE.Group();
    lineGroup.name='lineGroup';
            var params = {
                edgeStrength: 3.0,
                edgeGlow: 0.0,
                edgeThickness: 1.0,
                pulsePeriod: 0,
                rotate: false,
                usePatternTexture: false
            };
        var lineMaterial = new THREE.LineBasicMaterial({
            color: 0x0000ff,
            linewidth :1,
            opacity:0.9
        });

            // Init gui
            var gui = new dat.GUI();
            gui.add(params, "edgeStrength", 0.01, 10).onChange(function( value ) {
                outlinePass.edgeStrength = Number(value);
            });
            gui.add(params, "edgeGlow", 0.0, 1).onChange(function( value ) {
                outlinePass.edgeGlow = Number(value);
            });
            gui.add(params, "edgeThickness", 1, 4).onChange(function( value ) {
                outlinePass.edgeThickness = Number(value);
            });
            gui.add(params, "pulsePeriod", 0.0, 5).onChange(function( value ) {
                outlinePass.pulsePeriod = Number(value);
            });
            gui.add(params, "rotate");
            gui.add(params, "usePatternTexture").onChange(function( value ) {
                outlinePass.usePatternTexture = value;
            });
            var Configuration = function() {
                this.visibleEdgeColor = "#ffffff";
                this.hiddenEdgeColor  = "#190a05";
            };
            var conf = new Configuration();

            var controladorVisible = gui.addColor( conf, 'visibleEdgeColor');
            var controladorHidden = gui.addColor( conf, 'hiddenEdgeColor');
            controladorVisible.onChange(function( colorValue ) {
                //the return value by the chooser is like as: #ffff
                colorValue = colorValue.replace('#', '');
                function hexToRgb( hex ) {
                    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    return result ? {
                        r: parseInt(result[ 1 ], 16),
                        g: parseInt(result[ 2 ], 16),
                        b: parseInt(result[ 3 ], 16)
                    } : null;
                }

                var rgba  = hexToRgb(colorValue);
                var color = outlinePass.visibleEdgeColor;
                color.r   = rgba.r / 255;
                color.g   = rgba.g / 255;
                color.b   = rgba.b / 255;
            });

            controladorHidden.onChange(function( colorValue ) {
                //the return value by the chooser is like as: #ffff
                colorValue = colorValue.replace('#', '');
                function hexToRgb( hex ) {
                    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    return result ? {
                        r: parseInt(result[ 1 ], 16),
                        g: parseInt(result[ 2 ], 16),
                        b: parseInt(result[ 3 ], 16)
                    } : null;
                }

                var rgba  = hexToRgb(colorValue);
                color.r   = rgba.r / 255;
                color.g   = rgba.g / 255;
                color.b   = rgba.b / 255;
                var color = outlinePass.hiddenEdgeColor;
                
            });

            init();
            animate();

            function init() {

                container = document.createElement( 'div' );
                document.body.appendChild( container );

                var width = window.innerWidth || 1;
                var height = window.innerHeight || 1;
                var devicePixelRatio = window.devicePixelRatio || 1;

                renderer = new THREE.WebGLRenderer( { antialias: false } );
                renderer.shadowMap.enabled = true;
                renderer.setClearColor( 0xa0a0a0 );
                renderer.setPixelRatio( 1 );
                renderer.setSize( width, height );
                document.body.appendChild( renderer.domElement );

                camera = new THREE.PerspectiveCamera( 45, width / height, 0.1, 100 );
                camera.position.z = 8;
                camera.position.x = 0;

                scene = new THREE.Scene();

        new THREE.ObjectLoader().load( 'scene.json', function ( loadedScene ) {
        scene = new THREE.Scene();
        scene = loadedScene;

        scene.traverse( function ( sceneChild ) {

            if ( sceneChild.type === 'PerspectiveCamera' ) {

                camera = sceneChild;
                camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
                camera.updateProjectionMatrix();

            }

            if(sceneChild.type == 'Mesh'){

                if(sceneChild.geometry.type == 'BoxBufferGeometry' || sceneChild.geometry.type == 'SphereBufferGeometry'){
                    sceneChild.geometry.center();
                    sceneChild.geometry.computeBoundingSphere();
                    scale = 0.2*sceneChild.geometry.boundingSphere.radius;
                    boxGroup.push(sceneChild);
                    geometry.vertices.push(sceneChild.position);
                }
            }

        } );
        //geometry.vertices.push(geometry.vertices[0]);
    
        var line = new THREE.Line( geometry, lineMaterial );
        line.position.y -= 1;
        scene.add( line );


        // ... else create a new camera and use it in the loaded scene

        if ( camera === undefined ) {

            camera = new THREE.PerspectiveCamera( 45, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 10000 );
            camera.position.set( 10, 30, 20 );

        }

        controls = new THREE.OrbitControls( camera );
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;

        scene.background = new THREE.Color(0x111111);
        //document.addEventListener( 'mousedown', onDocumentMouseDown, false );
        document.addEventListener( 'mousemove', onTouchMove );
        document.addEventListener( 'touchmove', onTouchMove );

            } );

                stats = new Stats();
                container.appendChild( stats.dom );

                // postprocessing
                composer = new THREE.EffectComposer( renderer );

                var renderPass = new THREE.RenderPass( scene, camera );
                composer.addPass( renderPass );

                outlinePass = new THREE.OutlinePass( new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
                composer.addPass( outlinePass );
                var onLoad = function ( texture ) {
                    outlinePass.patternTexture = texture;
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                };

                var loader = new THREE.TextureLoader();

                // load a resource
                loader.load(
                    // resource URL
                    'tri_pattern.jpg',
                    // Function when resource is loaded
                    onLoad
                );

                effectFXAA = new THREE.ShaderPass(THREE.FXAAShader);
                effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight );
                effectFXAA.renderToScreen = true;
                composer.addPass( effectFXAA );

                window.addEventListener( 'resize', onWindowResize, false );

                window.addEventListener( 'mousemove', onTouchMove );
                window.addEventListener( 'touchmove', onTouchMove );

                function onTouchMove( event ) {

                    var x, y;

                    if ( event.changedTouches ) {

                        x = event.changedTouches[ 0 ].pageX;
                        y = event.changedTouches[ 0 ].pageY;

                    } else {

                        x = event.clientX;
                        y = event.clientY;

                    }

                    mouse.x = ( x / window.innerWidth ) * 2 - 1;
                    mouse.y = - ( y / window.innerHeight ) * 2 + 1;

                    checkIntersection();

                }

                function addSelectedObject(object) {
                    selectedObjects = [];
                    selectedObjects.push(object);
                }

                function checkIntersection() {

                    raycaster.setFromCamera( mouse, camera );

                    var intersects = raycaster.intersectObjects( [ scene ], true );

                    if ( intersects.length > 0 ) {
                        var selectedObject = intersects[ 0 ].object;
                        addSelectedObject(selectedObject);
                        outlinePass.selectedObjects = selectedObjects;
                    }
                    else {
                        // outlinePass.selectedObjects = [];
                    }
                }

            }

            function onWindowResize() {

                var width = window.innerWidth || 1;
                var height = window.innerHeight || 1;
                var devicePixelRatio = window.devicePixelRatio || 1;

                camera.aspect = width / height;
                camera.updateProjectionMatrix();

                renderer.setSize( width, height );
                composer.setSize( width, height );
                effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight );
            }

            function animate() {

                requestAnimationFrame( animate );

                stats.begin();

                var timer = performance.now();
                if(params.rotate)
                    group.rotation.y = timer * 0.0001;
                renderer.autoClear = true;
                renderer.setClearColor( 0xfff0f0 );
                renderer.setClearAlpha( 0.0 );

                composer.render();
                stats.end();
            }


        </script>
    </body>
</html>
