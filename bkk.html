<!DOCTYPE html>
<html>

<head>
    <title>Example 11.03 - Post processing masks</title>
    <script type="text/javascript" src="build/three.js"></script>

    <script type="text/javascript" src="js/libs/stats.min.js"></script>
    <script type="text/javascript" src="js/libs/dat.gui.min.js"></script>
    <script type="text/javascript" src="js/controls/OrbitControls.js"></script>
    <script type="text/javascript" src="js/postprocessing/ShaderPass.js"></script>
    <script type="text/javascript" src="js/shaders/CopyShader.js"></script>
    <script type="text/javascript" src="js/shaders/ColorifyShader.js"></script>

    <script type="text/javascript" src="js/postprocessing/BloomPass.js"></script>
    <script type="text/javascript" src="js/shaders/ConvolutionShader.js"></script>

    <script type="text/javascript" src="js/postprocessing/EffectComposer.js"></script>

    <script type="text/javascript" src="js/postprocessing/MaskPass.js"></script>
    <script type="text/javascript" src="js/postprocessing/FilmPass.js"></script>
    <script type="text/javascript" src="js/shaders/FilmShader.js"></script>
    <script type="text/javascript" src="js/shaders/SepiaShader.js"></script>
    <script type="text/javascript" src="js/postprocessing/RenderPass.js"></script>
    <script type="text/javascript" src="js/postprocessing/SavePass.js"></script>
    <script type="text/javascript" src="js/postprocessing/TexturePass.js"></script>

    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

<div id="Stats-output">
</div>
<!-- Div which will hold the Output -->
<div id="WebGL-output">
</div>

<!-- Javascript code that runs our Three.js examples -->
<script type="text/javascript">

    // once everything is loaded, we run our Three.js stuff.
    function init() {

        var stats = initStats();

        // create a scene, that will hold all our elements such as objects, cameras and lights.
        var scene = new THREE.Scene();
        var sceneBG = new THREE.Scene();

        // create a camera, which defines where we're looking at.
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        var cameraBG = new THREE.OrthographicCamera(-window.innerWidth, window.innerWidth, window.innerHeight, -window.innerHeight, -10000, 10000);
        cameraBG.position.z = 50;

        var group = new THREE.Group();
        var raycaster = new THREE.Raycaster();

        var mouse = new THREE.Vector2();
        var selectedObjects = [];
        var geometry = new THREE.Geometry();//存放线条的vertices
        var geometryChange = new THREE.Geometry();//存放当前选中物体相关线条的vertices

        var lineGroup = new THREE.Group();//存放动态线条（柱子）
        lineGroup.name='lineGroup';

        // create a render and set the size
        var renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(new THREE.Color(0x000, 1.0));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMapEnabled = true;
        
        // position and point the camera to the center of the scene
        camera.position.x = -10;
        camera.position.y = 15;
        camera.position.z = 25;

        camera.lookAt(new THREE.Vector3(0, 0, 0));

        controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.minDistance = 2;
        controls.maxDistance = 30;
        controls.enablePan = false;
        controls.zoomSpeed = 1.0;
        controls.panSpeed = 1.0;
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        var clock = new THREE.Clock();
        
        function initScene(){
            var pl1h=-6;//各个plane层次高度
            var pl2h=0;
            var pl3h=6;
            var opacity =0.7;
            var transparent=true;
            var loader = new THREE.TextureLoader();

            loader.load(

                'IT/first.png',
                function ( texture ) {

                    var material = new THREE.MeshStandardMaterial( {
                        side: THREE.DoubleSide,
                        map: texture
                     } );
                    material.opacity = opacity;
                    material.transparent = transparent; 
                    var geometry = new THREE.PlaneBufferGeometry( 20, 10, 3.98 );
                    var plane1 = new THREE.Mesh( geometry, material );
                    plane1.rotateX(-Math.PI/2);
                    plane1.position.set(0,pl1h,0);
                    plane1.receiveShadow=true;
                    scene.add( plane1 );
                },

                function ( xhr ) {
                    console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
                },

                function ( xhr ) {
                    console.log( 'An error happened' );
                }
            );
            loader.load(

                'IT/second.png',

                function ( texture ) {

                    var material = new THREE.MeshStandardMaterial( {
                        side: THREE.DoubleSide,
                        map: texture
                     } );
                    material.opacity = opacity;
                    material.transparent = transparent; 
                    var geometry = new THREE.PlaneBufferGeometry( 20, 10, 3.98 );
                    var plane1 = new THREE.Mesh( geometry, material );
                    plane1.rotateX(-Math.PI/2);
                    plane1.position.set(0,pl2h,0);
                    plane1.receiveShadow=true;
                    scene.add( plane1 );
                },

                function ( xhr ) {
                    console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
                },

                function ( xhr ) {
                    console.log( 'An error happened' );
                }
            );

            loader.load(

                'IT/third.png',

                function ( texture ) {

                    var material = new THREE.MeshStandardMaterial( {
                        side: THREE.DoubleSide,
                        map: texture
                     } );
                    material.opacity = opacity;
                    material.transparent = transparent; 
                    var geometry = new THREE.PlaneBufferGeometry( 20, 10, 3.98 );
                    var plane1 = new THREE.Mesh( geometry, material );
                    plane1.rotateX(-Math.PI/2);
                    plane1.position.set(0,pl3h,0);
                    plane1.receiveShadow=true;
                    scene.add( plane1 );
                },
                function ( xhr ) {
                    console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
                },

                function ( xhr ) {
                    console.log( 'An error happened' );
                }
            );
            var bluematerial = new THREE.MeshPhongMaterial( {color: 0x66ffff,emissive:0x66ffff} );
            var yellowmaterial = new THREE.MeshPhongMaterial( {color: 0xFF9900} );
            var whitematerial = new THREE.MeshPhongMaterial( {color: 0xffdfc5} );

            var geometry2 = new THREE.BoxBufferGeometry( 1, 2, 1 );
            var geometry1 = new THREE.BoxBufferGeometry( 1, 1, 1 );

            var box1 = new THREE.Mesh( geometry1, whitematerial );
            box1.position.set(-5.6,pl1h+0.6,-3);
            box1.castShadow=true;
            group.add( box1 );
            geometry.vertices.push(box1.position);
            
            var box2 = new THREE.Mesh( geometry2, bluematerial );
            box2.position.set(-5.8,pl1h+1.1,-0.9);
            box2.castShadow=true;
            group.add( box2 );
            geometry.vertices.push(box2.position);

            var box3 = new THREE.Mesh( geometry2, bluematerial );
            box3.position.set(-5.6,pl1h+1.1,1.4);
            box3.castShadow=true;
            group.add( box3 );
            geometry.vertices.push(box3.position);

            var box4 = new THREE.Mesh( geometry1, whitematerial );
            box4.position.set(-1.8,pl1h+0.6,-2.1);
            box4.castShadow=true;
            group.add( box4 );
            geometry.vertices.push(box4.position);

            var box5 = new THREE.Mesh( geometry1, whitematerial );
            box5.position.set(-1.8,pl1h+0.6,0);
            box5.castShadow=true;
            group.add( box5 );
            geometry.vertices.push(box5.position);

            var box6 = new THREE.Mesh( geometry2, bluematerial );
            box6.position.set(2,pl1h+1.1,-3);
            box6.castShadow=true;
            group.add( box6 );
            geometry.vertices.push(box6.position);

            var box7 = new THREE.Mesh( geometry2, yellowmaterial );
            box7.position.set(3,pl1h+1.1,-1);
            box7.castShadow=true;
            group.add( box7 );
            geometry.vertices.push(box7.position);

            var box8 = new THREE.Mesh( geometry2, yellowmaterial );
            box8.position.set(2.7,pl1h+1.1,2);
            box8.castShadow=true;
            group.add( box8 );
            geometry.vertices.push(box8.position);

            var box9 = new THREE.Mesh( geometry2, bluematerial );
            box9.position.set(6.7,pl1h+1.1,-3);
            box9.castShadow=true;
            group.add( box9 );
            geometry.vertices.push(box9.position);

            var box10 = new THREE.Mesh( geometry2, yellowmaterial );
            box10.position.set(5.5,pl1h+1.1,0.5);
            box10.castShadow=true;
            group.add( box10 );
            geometry.vertices.push(box10.position);

            var box11 = new THREE.Mesh( geometry2, yellowmaterial );
            box11.position.set(7.4,pl1h+1.1,2.2);
            box11.castShadow=true;
            group.add( box11 );
            geometry.vertices.push(box11.position);


            var box12 = new THREE.Mesh( geometry1, whitematerial );
            box12.position.set(3.6,pl2h+0.6,-0.4);
            box12.castShadow=true;
            group.add( box12 );

            var box13 = new THREE.Mesh( geometry1, whitematerial );
            box13.position.set(3.6,pl2h+.6,1.5);
            box13.castShadow=true;
            group.add( box13 );

            var box14 = new THREE.Mesh( geometry1, whitematerial );
            box14.position.set(7,pl2h+.6,-0.4);
            box14.castShadow=true;
            group.add( box14 );

            var box15 = new THREE.Mesh( geometry1, whitematerial );
            box15.position.set(7,pl2h+.6,1.5);
            box15.castShadow=true;
            group.add( box15 );

            var box16 = new THREE.Mesh( geometry2, yellowmaterial );
            box16.position.set(4.5,pl3h+1.1,0.4);
            box16.castShadow=true;
            group.add( box16 );

            scene.add(group);

            var light = new THREE.PointLight( 0xffffff, 1, 100 );
            light.position.set( -8, 9, 0 );
            scene.add( light );

            light = new THREE.PointLight( 0xffffff, 1, 100 );
            light.position.set( 16, 9, 15 );
            scene.add( light );

            var light = new THREE.PointLight( 0xffffff, 1, 100 );
            light.position.set( 5, 15, 0 );
            scene.add( light );

            var light = new THREE.PointLight( 0xffffff, 1, 100 );
            light.position.set( -5, 15, 15 );
            scene.add( light );

            var light = new THREE.PointLight( 0x68D8C7, 1, 100 );
            light.position.set( 0, -15, -10 );
            scene.add( light );

            var light = new THREE.AmbientLight( 0xCAF4EC);
            scene.add( light );

            camera.position.set( 7, 23, 20 );

            window.addEventListener( 'resize', onWindowResize, false );

            window.addEventListener( 'mousemove', onTouchMove );
            window.addEventListener( 'touchmove', onTouchMove );
            document.addEventListener( 'mousedown', onDocumentMouseDown, false );

            function onDocumentMouseDown( event ) {

                event.preventDefault();
                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
                raycaster.setFromCamera( mouse, camera );
                var intersects = raycaster.intersectObjects( [group], true );
                
                if ( intersects.length > 0 && (intersects[0].object.geometry.type== 'BoxBufferGeometry' ) ) {
                    if (intersects[0].object.position.y<=(pl1h+1.1)) {

                        var object = intersects[0].object;
                        geometryChange = new THREE.Geometry();
                        var position = intersects[0].object.position;
                        //搜索 geometry.vertices 中的 position 重新绘制选中物体相关linet
                        var p = geometry.vertices.length;
                        for(i=0;i<p;i++){
                            if(geometry.vertices[i] == position){

                                if (i == p - 1){
                                    geometryChange.vertices.push(geometry.vertices[p - 2]);
                                    geometryChange.vertices.push(position);
                                }
                                else if(i == 0){
                                    geometryChange.vertices.push(position);
                                    geometryChange.vertices.push(geometry.vertices[i+1]);
                                }

                                else{
                                    geometryChange.vertices.push(geometry.vertices[i-1]);
                                    geometryChange.vertices.push(position);
                                    geometryChange.vertices.push(geometry.vertices[i+1]);
                                  
                                }
                            }
                        }
                        var temp = geometryChange.vertices.length;
                        var xyz = geometryChange.vertices;
                        var material = new THREE.MeshPhongMaterial( {
                                        color: 0x156289,
                                        emissive: 0x00FFFF,
                                        side: THREE.DoubleSide,
                                        shading: THREE.FlatShading,
                                        vertexColors:THREE.FaceColors
                                    } );
                        var x,y,z,xw,zh,cheight;//position(x,y,z),xw是长，y是高，zh
                        for(i=0;i<temp-1;i++){
                            x= (xyz[i].x+xyz[i+1].x)/2;
                            y=-5.9;
                            z=(xyz[i].z+xyz[i+1].z)/2;
                            xw=xyz[i].x-xyz[i+1].x;
                            zh=xyz[i].z-xyz[i+1].z;
                            cheight=Math.sqrt(xw*xw+zh*zh);//圆柱体长度
                            var geometryCylinderLine = new THREE.CylinderBufferGeometry( 0.02, 0.02, cheight,20 );
                            var cylinder = new THREE.Mesh( geometryCylinderLine, material );
                            cylinder.position.set( x, y, z );//两实体的中点
                            cylinder.rotation.x -= Math.PI * 0.5;
                            //考虑到局部坐标系和全局坐标系的转换，柱体是在全局坐标系下旋转
                            if(xyz[i].x > xyz[i+1].x && xyz[i].z < xyz[i+1].z)
                                cylinder.rotation.z -= Math.asin(xw/cheight);//Math.asin(xw/cheight)为柱体要旋转的角度
                            else if(xyz[i].x > xyz[i+1].x && xyz[i].z > xyz[i+1].z)
                                cylinder.rotation.z += Math.asin(xw/cheight);
                            else if(xyz[i].x < xyz[i+1].x && xyz[i].z < xyz[i+1].z)
                                cylinder.rotation.z -= Math.asin(xw/cheight);
                            else
                                cylinder.rotation.z += Math.asin(xw/cheight);

                            cylinder.castShadow = true;
                            cylinder.receiveShadow = true;

                            lineGroup.add( cylinder );
                        }

                        loader.load(
                            'IT/word2.png',
                            function ( texture ) {
                                var material = new THREE.MeshPhongMaterial( {
                                    side: THREE.DoubleSide,
                                    map: texture
                                 } );
                                material.opacity = 0.8;
                                material.transparent = true;
                                var geometry = new THREE.PlaneBufferGeometry( 4, 1.5, 1 );
                                var plane1 = new THREE.Mesh( geometry, material );
                                plane1.position.set(15,pl1h+3,0);
                                lineGroup.add( plane1 );
                                var lmaterial = new THREE.LineBasicMaterial({
                                    color: 0x66ffff
                                    });
                                var lgeometry = new THREE.Geometry();
                                lgeometry.vertices.push(new THREE.Vector3( 13,pl1h+3,0 ),
                                                        new THREE.Vector3( 10,pl1h+3,0 ),
                                                        intersects[0].object.position);
                                var line = new THREE.Line(lgeometry,lmaterial);
                                lineGroup.add(line);
                            },
                            function ( xhr ) {
                                console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
                            },
                            function ( xhr ) {
                                console.log( 'An error happened' );
                            }
                        );
                        
                    }//if
            //最底层连线
                else if (intersects[0].object.position.y<=(pl2h+1.1) && intersects[0].object.position.y>(pl1h+1.1)) {
                    var lmaterial = new THREE.LineBasicMaterial({
                        color: 0x66ffff
                        });
            
                    for(i=1;i<=11;i++){
                        var lgeometry = new THREE.Geometry();
                        lgeometry.vertices.push(intersects[0].object.position,geometry.vertices[i-1]);
                        var line = new THREE.Line(lgeometry,lmaterial);
                        lineGroup.add(line);
                    }

                    loader.load(

                        'IT/word2.png',
                        function ( texture ) {
                            var material = new THREE.MeshPhongMaterial( {
                                side: THREE.DoubleSide,
                                map: texture
                             } );
                            material.opacity = 0.8;
                            material.transparent = true;
                            var geometry = new THREE.PlaneBufferGeometry( 4, 1.5, 1 );
                            var plane1 = new THREE.Mesh( geometry, material );
                            plane1.position.set(15,pl2h+3,0);
                            lineGroup.add( plane1 );
                            var lmaterial = new THREE.LineBasicMaterial({
                                color: 0x66ffff
                                });
                            var lgeometry = new THREE.Geometry();
                            lgeometry.vertices.push(new THREE.Vector3( 13,pl2h+3,0 ),
                                                    new THREE.Vector3( 10,pl2h+3,0 ),
                                                    intersects[0].object.position);
                            var line = new THREE.Line(lgeometry,lmaterial);
                            lineGroup.add(line);    
                        },
                        function ( xhr ) {
                            console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
                        },
                        function ( xhr ) {
                            console.log( 'An error happened' );
                        }
                    );
               }//elseif
                else{

                    //只重画当前选中部分的线条，删除则显示所有选中部分的线条
                    scene.traverse( function ( sceneChild ) {
                        if ( sceneChild.name === 'lineGroup' ) {
                        sceneChild.children = new Array();
                        scene.remove(sceneChild);
                        }
                    } );
                    
                    var xma = new THREE.LineBasicMaterial({
                        color: 0xffdfc5
                        });
                    var lgeometry = new THREE.Geometry();
                    lgeometry.vertices.push(intersects[0].object.position,new THREE.Vector3( 7,pl2h+.5,1.5 ));
                    var line = new THREE.Line(lgeometry,xma);
                    lineGroup.add(line);
                    var lgeometry = new THREE.Geometry();
                    lgeometry.vertices.push(intersects[0].object.position,new THREE.Vector3( 7,pl2h+.5,-0.4 ));
                    var line = new THREE.Line(lgeometry,xma);
                    lineGroup.add(line);
                    var lgeometry = new THREE.Geometry();
                    lgeometry.vertices.push(intersects[0].object.position,new THREE.Vector3( 3.6,pl2h+.5,1.5 ));
                    var line = new THREE.Line(lgeometry,xma);
                    lineGroup.add(line);
                    var lgeometry = new THREE.Geometry();
                    lgeometry.vertices.push(intersects[0].object.position,new THREE.Vector3( 3.6,pl2h+.5,-0.4 ));
                    var line = new THREE.Line(lgeometry,xma);
                    lineGroup.add(line);

                    loader.load(
                        'IT/word1.png',
                        function ( texture ) {
                            var material = new THREE.MeshPhongMaterial( {
                                side: THREE.DoubleSide,
                                map: texture
                             } );
                            material.opacity = 0.8;
                            material.transparent = true;
                            var geometry = new THREE.PlaneBufferGeometry( 4, 1.5, 1 );
                            var plane1 = new THREE.Mesh( geometry, material );
                            plane1.position.set(15,pl3h+3,0);
                            lineGroup.add( plane1 );
                            var lmaterial = new THREE.LineBasicMaterial({
                                color: 0x66ffff
                                });
                            var lgeometry = new THREE.Geometry();
                            lgeometry.vertices.push(new THREE.Vector3( 13,pl3h+3,0 ),
                                                    new THREE.Vector3( 10,pl3h+3,0 ),
                                                    intersects[0].object.position);
                            var line = new THREE.Line(lgeometry,lmaterial);
                            lineGroup.add(line);

                        },
                        function ( xhr ) {
                            console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
                        },
                        function ( xhr ) {
                            console.log( 'An error happened' );
                        }
                    );
               }

                scene.add( lineGroup );
                selectedObjects = [];
                selectedObjects.push( lineGroup );//给选中的线条和物体加发光特效
                selectedObjects.push( intersects[ 0 ].object );
                //outlinePass.selectedObjects = selectedObjects;
            }

            
        }
        function onTouchMove( event ) {

            var x, y;

            if ( event.changedTouches ) {

                x = event.changedTouches[ 0 ].pageX;
                y = event.changedTouches[ 0 ].pageY;

            } else {

                x = event.clientX;
                y = event.clientY;

            }

            mouse.x = ( x / window.innerWidth ) * 2 - 1;
            mouse.y = - ( y / window.innerHeight ) * 2 + 1;

            checkIntersection();

        }

        function checkIntersection() {

            raycaster.setFromCamera( mouse, camera );

                    var intersects = raycaster.intersectObjects( [group], true );

                    if ( intersects.length > 0 ) {

                        var selectedObject = intersects[ 0 ].object;
                        //addSelectedObject( selectedObject );
                        //outlinePass.selectedObjects = selectedObjects;

                    } else {

                    }
        }
    }

        var materialColor = new THREE.MeshBasicMaterial({
            map: THREE.ImageUtils.loadTexture("IT/background.png"),
            depthTest: false
        });
        var bgPlane = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), materialColor);
        bgPlane.position.z = -100;
        bgPlane.scale.set(window.innerWidth * 2, window.innerHeight * 2, 1);
        sceneBG.add(bgPlane);

        initScene();

        // add the output of the renderer to the html element
        document.getElementById("WebGL-output").appendChild(renderer.domElement);

        var bgPass = new THREE.RenderPass(sceneBG, cameraBG);
        var renderPass = new THREE.RenderPass(scene, camera);
        renderPass.clear = false;


        var effectCopy = new THREE.ShaderPass(THREE.CopyShader);
        effectCopy.renderToScreen = true;


        var clearMask = new THREE.ClearMaskPass();
        // earth mask
        var earthMask = new THREE.MaskPass(scene, camera);
//        earthMask.inverse = true;

        var effectSepia = new THREE.ShaderPass(THREE.SepiaShader);
        effectSepia.uniforms['amount'].value = 0.8;

        var effectColorify = new THREE.ShaderPass(THREE.ColorifyShader);
        effectColorify.uniforms['color'].value.setRGB(0.5, 0.5, 1);

       //var  outlinePass = new THREE.OutlinePass( new THREE.Vector2( window.innerWidth, window.innerHeight ), scene, camera );
                
        var bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.3, 0.1, 0.1);//1.0, 9, 0.5, 512);
        var effectFXAA = new THREE.ShaderPass(THREE.FXAAShader);
                effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight  );
                composer = new THREE.composer(renderer);

        var composer = new THREE.composer(renderer);
        composer.renderTarget1.stencilBuffer = true;
        composer.renderTarget2.stencilBuffer = true;

        composer.addPass(bgPass);
        composer.addPass(renderPass);
        //composer.addPass( outlinePass );
        //composer.addPass(effectColorify);
        composer.addPass(clearMask);
        composer.addPass(earthMask);
        //composer.addPass(effectSepia);
        composer.addPass(clearMask);

        composer.addPass(effectFXAA);
                composer.addPass(bloomPass);


        composer.addPass(effectCopy);

        window.addEventListener( 'resize', onWindowResize, false );

        render();

        function onWindowResize() {

                var width = window.innerWidth;
                var height = window.innerHeight;

                camera.aspect = width / height;
                camera.updateProjectionMatrix();

                cameraBG.left   = -width;
                cameraBG.right  =   width;
                cameraBG.top    =   height;
                cameraBG.bottom = - height;
                cameraBG.updateProjectionMatrix();
/*
                var frustumSize = 1000;
                var aspect = window.innerWidth / window.innerHeight;
                cameraBG.left   = - frustumSize * aspect / 2;
                cameraBG.right  =   frustumSize * aspect / 2;
                cameraBG.top    =   frustumSize / 2;
                cameraBG.bottom = - frustumSize / 2;
                cameraBG.updateProjectionMatrix();
*/
                renderer.setSize( width, height );
                composer.setSize( width, height );
            
            }

        function render() {

            renderer.autoClear = false;

            stats.update();


            //sphere.rotation.y=step+=0.01;
            var delta = clock.getDelta();
            controls.update(delta);

            // render using requestAnimationFrame
            requestAnimationFrame(render);
//            renderer.render(scene, camera);
            composer.render(delta);
        }

        function initStats() {

            var stats = new Stats();
            stats.setMode(0); // 0: fps, 1: ms

            // Align top-left
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';

            document.getElementById("Stats-output").appendChild(stats.domElement);

            return stats;
        }
    }
    window.onload = init;
</script>
</body>
</html>