<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - post processing - Outline Pass</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;
			}

			a {
				color:#00ff78;
			}

			#info {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				display:block;
			}
			.dg.ac {
				z-index: 1 !important; /* FIX DAT.GUI */
			}
		</style>
	</head>
	<body>
		<script src="../build/three.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/loaders/OBJLoader.js"></script>
	
		<script src="js/Detector.js"></script>

		<script src="js/shaders/CopyShader.js"></script>
		<script src="js/shaders/FXAAShader.js"></script>
		<script src="js/postprocessing/EffectComposer.js"></script>
		<script src="js/postprocessing/RenderPass.js"></script>
		<script src="js/postprocessing/ShaderPass.js"></script>
		<script src="js/postprocessing/OutlinePass.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src='js/libs/dat.gui.min.js'></script>
		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;
			var camera, scene, renderer, controls;
			var raycaster = new THREE.Raycaster();

			var mouse = new THREE.Vector2();
			var selectedObjects = [];

			var geometry = new THREE.Geometry();//存放线条的vertices
			var geometryChange = new THREE.Geometry();//存放当前选中物体相关线条的vertices

			var lineGroup = new THREE.Group();//存放动态线条（柱子）
    		lineGroup.name='lineGroup';

			var composer, effectFXAA, outlinePass;
			var obj3d = new THREE.Object3D();

			var group = new THREE.Group();

			var params = {
				edgeStrength: 3.0,
				edgeGlow: 0.0,
				edgeThickness: 1.0,
				pulsePeriod: 0,
				rotate: false,
				usePatternTexture: false
			};

			// Init gui

			var gui = new dat.GUI( { width: 300 } );

			gui.add( params, 'edgeStrength', 0.01, 10 ).onChange( function ( value ) {

				outlinePass.edgeStrength = Number( value );

			} );

			gui.add( params, 'edgeGlow', 0.0, 1 ).onChange( function ( value ) {

				outlinePass.edgeGlow = Number( value );

			} );

			gui.add( params, 'edgeThickness', 1, 4 ).onChange( function ( value ) {

				outlinePass.edgeThickness = Number( value );

			} );

			gui.add( params, 'pulsePeriod', 0.0, 5 ).onChange( function ( value ) {

				outlinePass.pulsePeriod = Number( value );

			} );

			gui.add( params, 'rotate' );

			gui.add( params, 'usePatternTexture' ).onChange( function ( value ) {

				outlinePass.usePatternTexture = value;

			} );

			var Configuration = function () {

				this.visibleEdgeColor = '#ffffff';
				this.hiddenEdgeColor = '#190a05';

			};

			var conf = new Configuration();

			var controllerVisible = gui.addColor( conf, 'visibleEdgeColor' ).onChange( function ( value ) {

				outlinePass.visibleEdgeColor.set( value );

			} );

			var controllerHidden = gui.addColor( conf, 'hiddenEdgeColor' ).onChange( function ( value ) {

				outlinePass.hiddenEdgeColor.set( value );

			} );

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				var width = window.innerWidth;
				var height = window.innerHeight;

				renderer = new THREE.WebGLRenderer( { antialias: false } );
				renderer.shadowMap.enabled = true;
				// todo - support pixelRatio in this demo
				renderer.setSize( width, height );
				document.body.appendChild( renderer.domElement );

				var manager = new THREE.LoadingManager();
				manager.onProgress = function ( item, loaded, total ) {

					console.log( item, loaded, total );

				};

				var onProgress = function ( xhr ) {
					if ( xhr.lengthComputable ) {
						var percentComplete = xhr.loaded / xhr.total * 100;
						console.log( Math.round(percentComplete, 2) + '% downloaded' );
					}
				};

				var onError = function ( xhr ) {
				};

				var url = 'nofloor.json';
				scene = new THREE.Scene();
				scene.add(group);


				var loader= new THREE.ObjectLoader();
				loader.load( url, function ( loadedScene ) {
					//scene = loadedScene;

					var objects = loadedScene.children;
					for(var i=0;i<objects.length;i++){

						if(objects[i].type == 'Mesh' ){

							objects[i].receiveShadow = true;
							objects[i].castShadow = true;
							geometry.vertices.push(objects[i].position);
							group.add(objects[i]);

						}
						
					}

				} , onProgress, onError);

				var floorMaterial = new THREE.MeshPhongMaterial({color:0x534F4F});
				floorMaterial.side = THREE.DoubleSide;
				var floorGeometry = new THREE.PlaneBufferGeometry( 20, 20 );
				var floorMesh = new THREE.Mesh( floorGeometry, floorMaterial );
				floorMesh.rotation.x -= Math.PI * 0.5;
				group.add( floorMesh );
				floorMesh.receiveShadow = true;

				var light = new THREE.PointLight( 0xffffff, 1, 100 );
				light.position.set( 0, 6, 0 );
				scene.add( light );

				light = new THREE.PointLight( 0xffffff, 1, 100 );
				light.position.set( 3, 6, 0 );
				scene.add( light );


				camera = new THREE.PerspectiveCamera( 45, width / height, 1, 10000 );
				camera.position.set( 0, 10, 20 );

				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.minDistance = 2;
				//controls.maxDistance = 20;
				//controls.enablePan = false;
				controls.enableDamping = true;
				controls.dampingFactor = 0.25;

				//
				

				stats = new Stats();
				container.appendChild( stats.dom );

				// postprocessing

				composer = new THREE.EffectComposer( renderer );

				var renderPass = new THREE.RenderPass( scene, camera );
				composer.addPass( renderPass );

				outlinePass = new THREE.OutlinePass( new THREE.Vector2( window.innerWidth, window.innerHeight ), scene, camera );
				composer.addPass( outlinePass );

				var onLoad = function ( texture ) {

					outlinePass.patternTexture = texture;
					texture.wrapS = THREE.RepeatWrapping;
					texture.wrapT = THREE.RepeatWrapping;

				};

				var loader = new THREE.TextureLoader();

				loader.load( 'tri_pattern.jpg', onLoad );

				effectFXAA = new THREE.ShaderPass( THREE.FXAAShader );
				effectFXAA.uniforms[ 'resolution' ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );
				effectFXAA.renderToScreen = true;
				composer.addPass( effectFXAA );

				window.addEventListener( 'resize', onWindowResize, false );

				window.addEventListener( 'mousemove', onTouchMove );
				window.addEventListener( 'touchmove', onTouchMove );
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				
				function onDocumentMouseDown( event ) {

			        event.preventDefault();
			        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
			        raycaster.setFromCamera( mouse, camera );
			        var intersects = raycaster.intersectObjects( [group], true );
			//只重画当前选中部分的线条，删除则显示所有选中部分的线条
			        scene.traverse( function ( sceneChild ) {
			            if ( sceneChild.name === 'lineGroup' ) {
			            sceneChild.children = new Array();
			            scene.remove(sceneChild);
			            }
			        } );
			        
			        if ( intersects.length > 0 && (intersects[0].object.geometry.type== 'BoxBufferGeometry' || intersects[0].object.geometry.type == 'SphereBufferGeometry') ) {

			            var object = intersects[0].object;
			            geometryChange = new THREE.Geometry();
			            var position = intersects[0].object.position;
			            //搜索 geometry.vertices 中的 position 重新绘制选中物体相关linet
			            var p = geometry.vertices.length;
			            for(i=0;i<p;i++){
			                if(geometry.vertices[i] == position){

			                    if (i == p - 1){
			                        geometryChange.vertices.push(geometry.vertices[p - 2]);
			                        geometryChange.vertices.push(position);
			                    }
			                    else if(i == 0){
			                        geometryChange.vertices.push(position);
			                        geometryChange.vertices.push(geometry.vertices[i+1]);
			                    }

			                    else{
			                        geometryChange.vertices.push(geometry.vertices[i-1]);
			                        geometryChange.vertices.push(position);
			                        geometryChange.vertices.push(geometry.vertices[i+1]);
			                      
			                    }
			                }
			            }
			            var temp = geometryChange.vertices.length;
			            var xyz = geometryChange.vertices;
			            var material = new THREE.MeshPhongMaterial( {
										color: 0x156289,
										emissive: 0x00FFFF,
										side: THREE.DoubleSide,
										shading: THREE.FlatShading,
										vertexColors:THREE.FaceColors
									} );
			            var x,y,z,xw,zh,cheight;//position(x,y,z),xw是长，y是高，zh
			            for(i=0;i<temp-1;i++){
			            	x= (xyz[i].x+xyz[i+1].x)/2;
			            	y=0.1;
			            	z=(xyz[i].z+xyz[i+1].z)/2;
			            	xw=xyz[i].x-xyz[i+1].x;
			            	zh=xyz[i].z-xyz[i+1].z;
			            	cheight=Math.sqrt(xw*xw+zh*zh);//圆柱体长度
			            	var geometryCylinderLine = new THREE.CylinderBufferGeometry( 0.02, 0.02, cheight,20 );
			            	var cylinder = new THREE.Mesh( geometryCylinderLine, material );
			            	cylinder.position.set( x, y, z );//两实体的中点
			            	cylinder.rotation.x -= Math.PI * 0.5;
			            	//考虑到局部坐标系和全局坐标系的转换，柱体是在全局坐标系下旋转
			            	if(xyz[i].x > xyz[i+1].x && xyz[i].z < xyz[i+1].z)
			            		cylinder.rotation.z -= Math.asin(xw/cheight);//Math.asin(xw/cheight)为柱体要旋转的角度
			            	else if(xyz[i].x > xyz[i+1].x && xyz[i].z > xyz[i+1].z)
			            		cylinder.rotation.z += Math.asin(xw/cheight);
			            	else if(xyz[i].x < xyz[i+1].x && xyz[i].z < xyz[i+1].z)
			            		cylinder.rotation.z -= Math.asin(xw/cheight);
			            	else
			            		cylinder.rotation.z += Math.asin(xw/cheight);

			            	cylinder.castShadow = true;
			            	cylinder.receiveShadow = true;
			            	//圆柱而不是cube
			            	lineGroup.add( cylinder );

			            }
            			scene.add( lineGroup );
            			selectedObjects = [];
						selectedObjects.push( lineGroup );//给选中的线条和物体加发光特效
						selectedObjects.push( intersects[ 0 ].object );
            			outlinePass.selectedObjects = selectedObjects;
			        }
			}

				function onTouchMove( event ) {

					var x, y;

					if ( event.changedTouches ) {

						x = event.changedTouches[ 0 ].pageX;
						y = event.changedTouches[ 0 ].pageY;

					} else {

						x = event.clientX;
						y = event.clientY;

					}

					mouse.x = ( x / window.innerWidth ) * 2 - 1;
					mouse.y = - ( y / window.innerHeight ) * 2 + 1;

					checkIntersection();

				}

				function addSelectedObject( object ) {

					selectedObjects = [];
					selectedObjects.push( object );

				}

				function checkIntersection() {

					raycaster.setFromCamera( mouse, camera );

					var intersects = raycaster.intersectObjects( [group], true );

					if ( intersects.length > 0 ) {

						var selectedObject = intersects[ 0 ].object;
						addSelectedObject( selectedObject );
						outlinePass.selectedObjects = selectedObjects;

					} else {

						// outlinePass.selectedObjects = [];

					}

				}

			}

			function onWindowResize() {

				var width = window.innerWidth;
				var height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );
				composer.setSize( width, height );

				effectFXAA.uniforms[ 'resolution' ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				stats.begin();

				var timer = performance.now();

				if ( params.rotate ) {

					group.rotation.y = timer * 0.0001;

				}

				controls.update();

				composer.render();

				stats.end();

			}

		</script>
	</body>
</html>
