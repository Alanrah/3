<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - post processing - Outline Pass</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;
			}

			a {
				color:#00ff78;
			}

			#info {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				display:block;
			}
			.dg.ac {
				z-index: 1 !important; /* FIX DAT.GUI */
			}
		</style>
	</head>
	<body>
		<script src="../build/three.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/loaders/OBJLoader.js"></script>
	
		<script src="js/Detector.js"></script>

		<script src="js/shaders/CopyShader.js"></script>
		<script src="js/shaders/FXAAShader.js"></script>
		<script src="js/postprocessing/EffectComposer.js"></script>
		<script src="js/postprocessing/RenderPass.js"></script>
		<script src="js/postprocessing/ShaderPass.js"></script>
		<script src="js/postprocessing/OutlinePass.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src='js/libs/dat.gui.min.js'></script>
		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;
			var camera, scene, renderer, controls;
			var raycaster = new THREE.Raycaster();

			var mouse = new THREE.Vector2();
			var selectedObjects = [];

			var geometry = new THREE.Geometry();//存放线条的vertices
			var geometryChange = new THREE.Geometry();//存放当前选中物体相关线条的vertices

			var lineGroup = new THREE.Group();//存放动态线条（柱子）
    		lineGroup.name='lineGroup';

			var composer, effectFXAA, outlinePass;
			var obj3d = new THREE.Object3D();

			var group = new THREE.Group();

			var params = {
				edgeStrength: 3.0,
				edgeGlow: 0.0,
				edgeThickness: 1.0,
				pulsePeriod: 0,
				rotate: false,
				usePatternTexture: false
			};

			// Init gui

			var gui = new dat.GUI( { width: 300 } );

			gui.add( params, 'edgeStrength', 0.01, 10 ).onChange( function ( value ) {

				outlinePass.edgeStrength = Number( value );

			} );

			gui.add( params, 'edgeGlow', 0.0, 1 ).onChange( function ( value ) {

				outlinePass.edgeGlow = Number( value );

			} );

			gui.add( params, 'edgeThickness', 1, 4 ).onChange( function ( value ) {

				outlinePass.edgeThickness = Number( value );

			} );

			gui.add( params, 'pulsePeriod', 0.0, 5 ).onChange( function ( value ) {

				outlinePass.pulsePeriod = Number( value );

			} );

			gui.add( params, 'rotate' );

			gui.add( params, 'usePatternTexture' ).onChange( function ( value ) {

				outlinePass.usePatternTexture = value;

			} );

			var Configuration = function () {

				this.visibleEdgeColor = '#ffffff';
				this.hiddenEdgeColor = '#190a05';

			};

			var conf = new Configuration();

			var controllerVisible = gui.addColor( conf, 'visibleEdgeColor' ).onChange( function ( value ) {

				outlinePass.visibleEdgeColor.set( value );

			} );

			var controllerHidden = gui.addColor( conf, 'hiddenEdgeColor' ).onChange( function ( value ) {

				outlinePass.hiddenEdgeColor.set( value );

			} );

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				var width = window.innerWidth;
				var height = window.innerHeight;

				renderer = new THREE.WebGLRenderer( { antialias: false } );
				renderer.shadowMap.enabled = true;
				// todo - support pixelRatio in this demo
				renderer.setSize( width, height );
				document.body.appendChild( renderer.domElement );

				var manager = new THREE.LoadingManager();
				manager.onProgress = function ( item, loaded, total ) {

					console.log( item, loaded, total );

				};

				var onProgress = function ( xhr ) {
					if ( xhr.lengthComputable ) {
						var percentComplete = xhr.loaded / xhr.total * 100;
						console.log( Math.round(percentComplete, 2) + '% downloaded' );
					}
				};

				var onError = function ( xhr ) {
				};

				var url = 'nofloor.json';
				scene = new THREE.Scene();
				scene.add(group);


				var loader= new THREE.ObjectLoader();
				loader.load( url, function ( loadedScene ) {
					//scene = loadedScene;
					console.log(loadedScene);
					var objects = loadedScene.children;
					for(var i=0;i<objects.length;i++){

						if(objects[i].type == 'Mesh' ){

							objects[i].receiveShadow = true;
							objects[i].castShadow = true;
							geometry.vertices.push(objects[i].position);
							group.add(objects[i]);

						}
						
					}

				} , onProgress, onError);

				var floorMaterial = new THREE.MeshPhongMaterial({color:0x534F4F});
				floorMaterial.side = THREE.DoubleSide;
				var floorGeometry = new THREE.PlaneBufferGeometry( 20, 20 );
				var floorMesh = new THREE.Mesh( floorGeometry, floorMaterial );
				floorMesh.rotation.x -= Math.PI * 0.5;
				scene.add( floorMesh );
				floorMesh.receiveShadow = true;

				var light = new THREE.PointLight( 0xffffff, 1, 100 );
				light.position.set( 0, 6, 0 );
				scene.add( light );

				light = new THREE.PointLight( 0xffffff, 1, 100 );
				light.position.set( 3, 6, 0 );
				scene.add( light );


				camera = new THREE.PerspectiveCamera( 45, width / height, 1, 10000 );
				camera.position.set( 10, 20, 10 );

				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.minDistance = 2;
				//controls.maxDistance = 20;
				//controls.enablePan = false;
				controls.enableDamping = true;
				controls.dampingFactor = 0.25;

				//
				

				stats = new Stats();
				container.appendChild( stats.dom );

				// postprocessing

				composer = new THREE.EffectComposer( renderer );

				var renderPass = new THREE.RenderPass( scene, camera );
				composer.addPass( renderPass );

				outlinePass = new THREE.OutlinePass( new THREE.Vector2( window.innerWidth, window.innerHeight ), scene, camera );
				composer.addPass( outlinePass );

				var onLoad = function ( texture ) {

					outlinePass.patternTexture = texture;
					texture.wrapS = THREE.RepeatWrapping;
					texture.wrapT = THREE.RepeatWrapping;

				};

				var loader = new THREE.TextureLoader();

				loader.load( 'tri_pattern.jpg', onLoad );

				effectFXAA = new THREE.ShaderPass( THREE.FXAAShader );
				effectFXAA.uniforms[ 'resolution' ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );
				effectFXAA.renderToScreen = true;
				composer.addPass( effectFXAA );
console.log(scene)
				window.addEventListener( 'resize', onWindowResize, false );

				window.addEventListener( 'mousemove', onTouchMove );
				window.addEventListener( 'touchmove', onTouchMove );
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				function onDocumentMouseDown( event ) {

        event.preventDefault();

        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

        raycaster.setFromCamera( mouse, camera );

        var intersects = raycaster.intersectObjects( [group],true );

        var lineChange = new THREE.Line( geometryChange, lineChangeMaterial );
        var geometryChange = new THREE.Geometry();
        var lineChangeMaterial = new THREE.LineBasicMaterial({
                color: 0xC02121,
                linewidth :30,
                opacity:1
            });
        scene.traverse( function ( sceneChild ) {

            if ( sceneChild.name === 'lineGroup' ) {
            sceneChild.children = new Array();
            scene.remove(sceneChild);

            }

        } );
        
        if ( intersects.length > 0 ) {

            geometryChange = new THREE.Geometry();

            var object = intersects[0].object;
            var position = intersects[0].object.position;

            //搜索 geometry.vertices 中的 position 重新绘制选中物体相关linet
            var p = geometry.vertices.length;
            for(i=0;i<p;i++){
                if(geometry.vertices[i] == position){

                    if (i == p - 1){
                        geometryChange.vertices.push(geometry.vertices[p - 2]);
                        geometryChange.vertices.push(position);
                    }
                    else if(i == 0){
                        geometryChange.vertices.push(position);
                        geometryChange.vertices.push(geometry.vertices[i+1]);
                    }

                    else{
                        geometryChange.vertices.push(geometry.vertices[i-1]);
                        geometryChange.vertices.push(position);
                        geometryChange.vertices.push(geometry.vertices[i+1]);
                        
                    }
                }
            }
            lineChange = new THREE.Line( geometryChange, lineChangeMaterial );
            lineChange.position.y -= 1;
            lineGroup.add(lineChange)
            scene.add( lineGroup );

        }

     }
				function onTouchMove( event ) {

					var x, y;

					if ( event.changedTouches ) {

						x = event.changedTouches[ 0 ].pageX;
						y = event.changedTouches[ 0 ].pageY;

					} else {

						x = event.clientX;
						y = event.clientY;

					}

					mouse.x = ( x / window.innerWidth ) * 2 - 1;
					mouse.y = - ( y / window.innerHeight ) * 2 + 1;

					checkIntersection();

				}

				function addSelectedObject( object ) {

					selectedObjects = [];
					selectedObjects.push( object );

				}

				function checkIntersection() {

					raycaster.setFromCamera( mouse, camera );

					var intersects = raycaster.intersectObjects( [group], true );

					if ( intersects.length > 0 ) {

						var selectedObject = intersects[ 0 ].object;
						addSelectedObject( selectedObject );
						outlinePass.selectedObjects = selectedObjects;

					} else {

						// outlinePass.selectedObjects = [];

					}

				}

			}

			function onWindowResize() {

				var width = window.innerWidth;
				var height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );
				composer.setSize( width, height );

				effectFXAA.uniforms[ 'resolution' ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				stats.begin();

				var timer = performance.now();

				if ( params.rotate ) {

					group.rotation.y = timer * 0.0001;

				}

				controls.update();

				composer.render();

				stats.end();

			}

		</script>
	</body>
</html>
